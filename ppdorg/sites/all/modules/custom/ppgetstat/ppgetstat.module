<?php

/**
 * @file
 * Drupal.org statistics routines.
 */

/**
 * Implements hook_menu().
 */
function ppgetstat_menu() {
  $items['admin/config/services/ppgetstat'] = array(
    'title' => 'Get user profiles',
    'description' => 'PPgetstat settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ppgetstat_settings_form'),
    'access arguments' => array('administer site configuration'),
    'weight' => -21,
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/content/ppgetstat_import'] = array(
    'title' => 'Stats Import',
    'description' => 'Manual import drupal.org users data.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ppgetstat_import_form'),
    'access arguments' => array('administer nodes'),
    'weight' => -21,
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Module ppgetstat settings form.
 *
 * @param array $form
 *   Drupal form.
 *
 * @param array $form_state
 *   Drupal fomr state.
 *
 * @return mixed
 *   Settings form for ppgetstat module.
 */
function ppgetstat_settings_form($form, &$form_state) {
  $form['ppgetstat_users'] = array(
    '#type' => 'textarea',
    '#title' => t('Users list'),
    '#description' => 'Please enter comma separated list of nicks per user line. If user has more than one nick. New line - new user.',
    '#default_value' => variable_get('ppgetstat_users'),
  );
  $form['ppgetstat_pages_to_scan'] = array(
    '#type' => 'textfield',
    '#title' => t('Pages to scan at once at drupal.org'),
    '#description' => 'Please enter integer value here.',
    '#default_value' => variable_get('ppgetstat_pages_to_scan'),
  );

  return system_settings_form($form);
}

/**
 * Module ppgetstat content import form.
 *
 * @param array $form
 *   Drupal form.
 *
 * @param array $form_state
 *   Drupal form state.
 *
 * @return mixed
 *   Form for ppgetstat manual import.
 */
function ppgetstat_import_form($form, &$form_state) {
  $form['ppgetstat_types'] = array(
    '#type' => 'checkboxes',
    '#options' => drupal_map_assoc(array('commits', 'posts(placeholder)')),
    '#title' => t('drupal.org user\'s data'),
  );
  $form['ppgetstat_import'] = array(
    '#type' => 'submit',
    '#value' => t('Import drupal.org data'),
  );

  return $form;
}

/**
 * Module ppgetstat content import form submit handler.
 *
 * @param array $form
 *   Drupal form.
 *
 * @param array $form_state
 *   Drupal form state.
 */
function ppgetstat_import_form_submit($form, &$form_state) {
  // Reset counter for debug information.
  drupal_set_message('<pre>' . print_r($form_state['values'], TRUE) . '</pre>');

  // Grab commits in a batch.
  if ($form_state['values']['ppgetstat_types']['commits'] == 'commits') {
    $_SESSION['http_request_count'] = 0;
    $function = 'ppgetstat_commits_batch_start';
    $batch = $function();
    batch_set($batch);
  }

  // @todo create batches for all other types.

}

/**
 * Prepare batch operations.
 *
 * @return array
 *   Array for commits batch routine.
 */
function ppgetstat_commits_batch_start() {

  $user_ids = ppgetstat_get_user_ids();
  $num_operations = count($user_ids);
  drupal_set_message(t('Creating an array of @num operations', array('@num' => $num_operations)));

  $operations = array();
  // Set up an operations array with some elements, each doing its own function
  // Each operation in the operations array means at least one new HTTP request,
  // running Drupal from scratch to accomplish the operation. If the operation
  // returns with $context['finished'] != TRUE, then it will be called again.
  // In this example, $context['finished'] is always TRUE.
  foreach ($user_ids as $nick => $id_user) {
    $operations[] = array(
      'ppgetstat_batch_op_1',
      array(
        ppgetstat_dorg_commits_request($id_user),
        t('(Get commits counter for user @nick)', array('@nick' => $nick)),
      ),
    );
  }

  $batch = array(
    'operations' => $operations,
    'finished' => 'ppgetstat_finished',
  );

  return $batch;
}

/**
 * Returns data for ppgetstat_batch_op_1($ret,...).
 *
 * @param array $id_user
 *   array(userid, username).
 *
 * @return array
 *   array('user' => username, 'commits' => 123).
 */
function ppgetstat_dorg_commits_request($id_user) {
  // @todo Cache downloaded pages to filesystem: files/dorgpages/nodeid_week_year.html

  // Drupal.org commits counter selector: "div.item-list li.last"
  $qp = htmlqp('https://drupal.org/user/' . $id_user[0], 'div.item-list li.last');

  // "Total: XXX commits"
  $commits_text = $qp->text();
  $commits_data = explode(" ", $commits_text);

  drupal_set_message($id_user[1] . '`s commits count:' . $commits_data[1]);
  return array(
    'user' => $id_user[1],
    'commits' => $commits_data[1],
  );
}

/**
 * Batch operation for batch 1: load a node.
 *
 * This is the function that is called on each operation in ppgetstat_commits_batch_start.
 */
function ppgetstat_batch_op_1($ret, $operation_details, &$context) {
  // @todo Save stats to nodes here. User will be passed count(nicks) time.

  drupal_set_message('Hello, batch world: <pre>' . print_r($ret, TRUE) . '</pre>');
  ppgetstat_update_http_requests();
}

/**
 * Utility function to increment HTTP requests in a session variable.
 */
function ppgetstat_update_http_requests() {
  $_SESSION['http_request_count']++;
}

/**
 * Utility function to count the HTTP requests in a session variable.
 *
 * @return int
 *   Number of requests.
 */
function ppgetstat_get_http_requests() {
  return !empty($_SESSION['http_request_count']) ? $_SESSION['http_request_count'] : 0;
}

/**
 * Batch 'finished' callback used by batch 1.
 */
function ppgetstat_finished($success, $results, $operations) {
  if ($success) {
    // Here we could do something meaningful with the results.
    // We just display the number of nodes we processed...
    drupal_set_message(
      t(
        '@count results processed in @requests HTTP requests.',
        array(
          '@count' => count($results),
          '@requests' => ppgetstat_get_http_requests()
        )
      )
    );
    drupal_set_message(t('The final result was "%final"', array('%final' => end($results))));
  }
  else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    drupal_set_message(
      t(
        'An error occurred while processing @operation with arguments : @args',
        array(
          '@operation' => $error_operation[0],
          '@args' => print_r($error_operation[0], TRUE),
        )
      )
    );
  }
}

/**
 * Get list of user ids.
 *
 * @return array
 *   Returns array('nick1' => array(id1, user), 'nick2' => array(id2, user)).
 */
function ppgetstat_get_user_ids() {

  $ids = variable_get('ppgetstat_get_user_ids', array());
  if (!empty($ids)) {
    return $ids;
  }

  $users = ppgetstat_get_users();
  $ids = array();
  foreach ($users as $user => $nicks) {
    foreach ($nicks as $nick) {
      $ids[$nick] = array(
        ppgetstat_get_id_by_nick($nick),
        $user,
      );
    }
  }
  variable_set('ppgetstat_get_user_ids', $ids);

  return $ids;
}

/**
 * Get drupal.org user ID using nickname and http://dgo.to.
 *
 * @param string $nick
 *   Nickname.
 *
 * @return int
 *   Drupal.org user id.
 */
function ppgetstat_get_id_by_nick($nick) {
  if ($id_cached = cache_get('ppgetstat_nick_' . $nick)) {
    return $id_cached->data;
  }
  $nick_data = drupal_http_request('http://dgo.to/@' . $nick);
  $request = parse_url($nick_data->redirect_url);
  $id_data = explode("/", $request['path']);
  $id = $id_data[2];
  cache_set('ppgetstat_nick_' . $nick, $id);

  return $id;
}

/**
 * Get associated array of users entered in settings.
 *
 * @return array
 *  Users array('user1' => array('user1_nick1', 'user1_nick2'), 'user2' => array('user2_nick)).
 */
function ppgetstat_get_users() {
  $users = variable_get('ppgetstat_users');
  $user = array();
  foreach (preg_split("/((\r?\n)|(\r\n?))/", $users) as $user_line) {
    $nicks = explode(',', $user_line);
    if (isset($nicks[0])) {
      $user[$nicks[0]] = $nicks;
    }
  }

  return $user;
}
